# Rendering

랜더링은 코드를 유저 인터페이스로 변경해준다.

리액트 18과 넥스트 13은 애플리케이션을 랜더하는 새로운 방법을 소개한다.
이 페이지는 랜더 환경, 전략, 런타임 그리고 최적화하는 방법을 이해하는 것에 도움을 준다.

## Rendering Environments

애플리케이션의 코드가 랜더 되는 2 가지 다른 환경이 있다: 클라이언트와 서버

![label](https://nextjs.org/_next/image?url%253D%252Fdocs%252Fdark%252Fclient-and-server-environments.png%2526w%253D1920%2526q%253D75%2526dpl%253Ddpl_BiT8GBjgDV3TRhmYBVrSvJxirRAk)

- 클라이언트는 서버에 애플리케이션 코드 요청을 보내는 유저의 기기다. 그 후 서버에서 응답을 받은 후 유저가 상호작용할 수 있는 인터페이스가 된다.
- 서버는 데이터가 저장된 컴퓨터로, 애플리케이션 코드, 클라이언트에서의 요청, 계산 그리고 적절한 응답을 보낸다.

> Good to know: 서버는 당신의 애플리케이션이 배포된 지역을 의미하고, 엣지 네트워크는 애플리케이션 코드가 분산된 곳을 CDN은 랜더의 결과가 캐시된 곳이다.

## Component-level Client and Server Rendering

리액트 18 이전에는, 리액트로 만들어진 애플리케이션은 오직 클라이언트 랜더를 했다.

넥스트는 페이지 단위로 쉽게 나누는 것과 리액트로 클라이언트에 하이드레이트된 서버로 부터 프리랜더된 html을 제공한다.
하지만, 이것은 초기 html이 상호작용하기 위해 추가적인 코드를 요구한다.

이제, 서버와 클라이언트 컴포넌트로 리액트는 클라이언트와 서버 랜더 환경을 컴포넌트 레벨에서 선택할 수 있다.

기본적으로, 앱 라우터는 서버 컴포넌트를 사용해, 서버에서 컴포넌트를 랜더하고 클라이언트에 보내지는 자바스크립트 양을 줄인다.

## Static and Dynamic Rendering on the Server

컴포넌트의 클라이언트 사이드 랜더링과 서버 사이드 랜더링와 추가로, 넥스트는 정적/동적 랜더링을 제공해 랜더링을 최적화할 수 있다.

### Static Rendering

정적 랜더링을 통해, 서버와 클라이언트 컴포넌트는 빌드시 서버에서 프리랜더 된다.
이 결과로 캐시를 통해 후속 요청에 재사용한다. 캐시된 결과는 또한 재확인된다.

> Good to know: 이것은 페이지 라우터의 SSG와 ISR과 동일하다.

서버와 클라이언트 컴포넌트는 정적 랜더링시 다르게 동작한다:

- 클라이언트 컴포넌트는 그들의 html과 json을 통해 서버에서 프리랜더되고 캐시된다. 캐시된 결과는 클라이언트에 보내져 하이드레이션된다.
- 서버 컴포넌트는 리액트에 의해 서버에서 랜더되고, 그들의 페이로드가 html을 생성하는 데 사용된다. 동일한 페이로드가 클라이언트에서 하이드레이션 되고, 그 결과 클라이언트에서 자바스크립트가 필요없다.

### Dynamic Rendering

각 서버와 클라이언트 컴포넌트는 동적 랜더링을 통해 요청시에 서버에서 랜더된다. 그 결과는 캐시되지 않는다.

> Good to know: 페이지 라우터의 getServerSideProps 와 동일

### Edge and Node.js Runtimes

서버에서, 페이지가 랜더되는 두 가지 런타임이 존재한다.

- node.js 런타임(기본) node.js api에 접근 가능하고 생태계의 패키지와 호환가능
- edge 런타임은 웹 api에 기반

각 런타임은 배포 설계에 따라 스트리밍을 서버에서 지원한다.

---

## What I Learned

맛보기로 넥스트의 랜더링 전략을 공부해 봤는데, 넥스트가 랜더링에 얼마나 힘을 쏟고 있는지 알 수 있었다.
