# Rendering

렌더링은 코드를 유저 인터페이스로 바꿔준다. 리액트와 넥스트는 코드가 서버 또는 클라이언트에서 렌더될 수 있도록 하는 하이브리드 웹 애플리케이션을 만들 수 있도록한다.

---

## \***\*[Fundamentals](https://nextjs.org/docs/app/building-your-application/rendering#fundamentals)\*\***

시작하기 전에, 기초적인 3가지 웹 컨셉을 아는 것이 도움이 된다.

- 애플리케이션의 코드가 실행되는 환경: 서버와 클라이언트
- 요청-응답 생명주기, 유저가 앱을 방문하고 상호작용 일을킬 때 발생
- 네트워크 바운더리, 서버와 클라이언트 코드를 분리하는

### \***\*[Rendering Environments](https://nextjs.org/docs/app/building-your-application/rendering#rendering-environments)\*\***

웹 애플리케이션이 렌더되는 서버와 클라이언트 두 환경이 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8587a611-937a-4b21-a548-105bd7bd2b91/783b807a-8590-4d81-a6cc-35d693fc6f6a/Untitled.png)

- 클라이언트란 애플리케이션의 코드의 요청을 서버에 보내는 장치다. 그 후, 서버에서 응답을 유저 인터페이스로 변경한다.
- 서버는 애플리케이션 코드를 저장하고, 클라이언트의 요청을 받고 적절한 응답을 보내주는 컴퓨터다.

역사적으로, 개발자들은 서버와 클라이언트 코드를 작성하기 위해선 다른 언어와 프레임워크를 사용해야했다. 리액트를 사용하면, 같은 언어와 같은 프레임워크를 사용할 수 있다. 이런 유동성은 두 환경에 문맥 전환 없이 쉽게 코드를 작성하게 해준다.

하지만, 각 환경은 그들만의 능력과 제약을 갖는다. 그러므로, 서버와 클라이언트 코드는 항상 같지 않다. 각자 환경에 맞는 특정한 동작이 있다.

이런 차이점을 아는 것은 리액트와 넥스트를 효율적으로 사용하는 키이다.

### \***\*[Request-Response Lifecycle](https://nextjs.org/docs/app/building-your-application/rendering#request-response-lifecycle)\*\***

대체로 모든 웹사이트는 동일한 요청-응답 생명주기를 갖는다.

1. 유저 액션: 유저가 웹 애플리케이션과 상호작용한다. 링크를 클릭하거나, 폼을 제출, 주소바에 URL을 직접 작성하는 것이 될 수 있다.
2. HTTP 요청: 클라이언트는 어떤 정보가 요청될 것인지, 어떤 메서드를 사용할지, 그리고 추가적인 데이터를 포함한 http 요청을 서버에 보낸다.
3. 서버: 서버는 요청을 받고 상응하는 자원을 응답한다. 이 과정은 몇 가지 단계가 걸린다.
4. HTTP 응답: 요청을 처리하고, 서버는 http 응답을 클라이언트로 보낸다. 이 응답은 상태 코드, 요청의 자원을 포함한다.
5. 클라이언트: 클라이언트는 자원을 파싱해서 유저 인터페이스로 렌더한다.
6. 유저 액션: 유저 인터페이스가 렌더되면, 유저는 그것과 상호작용 할 수 있다. 그리고 전체 과정을 다시 시작할 수 있다.

하이브리드 웹 애플리케이션을 만드는데 중요한 부분은 생명주기를 어떻게 나눌 것인가와 네트워크 바운더리를 어디에 둘것인가이다.

### \***\*[Network Boundary](https://nextjs.org/docs/app/building-your-application/rendering#network-boundary)\*\***

웹 개발에서, 네트워크 바운더리는 다른 환경을 나누기위한 컨셉이다. 예를 들어, 클라이언트와 서버 혹은 서버와 데이터 스토어.

리액트에서, 클라이언트-서버 네트워크 바운더리를 두는 것이 가장 말이 된다.

뒤에서, 동작은 두 부분으로 나윈다: 클라이언트 모듈 그래프와 서버 모듈 그래프. 서버 모듈 그래프는 서버에서 렌더되는 모든 컴포넌트를 포함하고, 클라이언트 모듈 그래프는 클라이언트에서 렌더되는 모든 컴포넌트를 포함한다.

모듈 그래프를 애플리케이션 파일이 서로 어떻게 의존하는지 나타내는 시각 자료라 생각하면 쉽다.

리액트의 `"use client"` 컨벤션으로 바운더리를 정의할 수 있고, `"use server"` 컨벤션으로 어떤 작업은 클라이언트지만, 서버에서 작동할 수 있도록 할 수 있다.

---

## \***\*[Building Hybrid Applications](https://nextjs.org/docs/app/building-your-application/rendering#building-hybrid-applications)\*\***

이런 환경에서 작업할 때, 애플리케이션의 코드를 단방향이라고 생각하는 것이 도움이 된다. 다른 말로, 응답 시, 애플리케이션 코드는 단방향으로 흐른다: 서버에서 클라이언트로.

만약 클라이어느에서 서버로 접근하는 경우, 동일한 요청을 재새용하는 것 대신, 서버에 새로운 요청을 보내야한다. 이것은 어디서 컴포넌트가 렌더되는지와 네트워크 바운더리 어디에 둘지를 쉽게 해준다.

이 모델은, 개발자에게 클라이언트에 결과를 보내는 것과 애플리케이션을 상호작용 하기전에, 어떤 것을 서버에서 우선적으로 실행해야하는지 생각하게 한다.
